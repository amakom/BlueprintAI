import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { SubscriptionStatus, PlanType, Currency } from '@prisma/client';

export async function POST(req: NextRequest) {
  const signature = req.headers.get('verif-hash');
  
  // In production, ensure FLUTTERWAVE_SECRET_HASH is set
  if (process.env.NODE_ENV === 'production' && (!signature || signature !== process.env.FLUTTERWAVE_SECRET_HASH)) {
    return NextResponse.json({ error: 'Invalid signature' }, { status: 401 });
  }

  const payload = await req.json();
  const { event, data } = payload;

  console.log('Flutterwave Webhook Event:', event);

  try {
    switch (event) {
      case 'charge.completed':
        if (data.status === 'successful') {
           await handleChargeCompleted(data);
        }
        break;
      case 'subscription.cancelled':
        await handleSubscriptionCancelled(data);
        break;
      default:
        console.log('Unhandled event:', event);
    }
    return NextResponse.json({ status: 'success' });
  } catch (error) {
    console.error('Webhook processing error:', error);
    return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
  }
}

async function handleChargeCompleted(data: any) {
  // data.tx_ref expected format: "bp_{teamId}_{planId}_{timestamp}"
  // or verify via email if tx_ref is generated by FW for recurring
  
  const txRef = data.tx_ref;
  const parts = txRef?.split('_');
  
  // Basic validation of tx_ref structure for initial payment
  // If it's a recurring charge, tx_ref might be different or preserved? 
  // Flutterwave recurring charges usually preserve the tx_ref or generate a new one?
  // Actually, for subscriptions, it's better to rely on customer email or metadata if available.
  
  // Let's try to find subscription by customer email or flutterwaveCustomerId
  const customerEmail = data.customer.email;
  
  // Find team by user email? No, subscription is per team.
  // We should have stored metadata. 
  // Assuming we pass meta: { teamId, planId } in the payment initialization.
  
  const teamId = data.meta?.teamId;
  const planId = data.meta?.planId; // 'pro', 'team'

  if (!teamId) {
      console.warn('Missing teamId in webhook metadata', data);
      return;
  }

  // Map string planId to Enum
  let planType: PlanType = PlanType.FREE;
  if (planId === 'pro') planType = PlanType.PRO;
  if (planId === 'team') planType = PlanType.TEAM;
  if (planId === 'enterprise') planType = PlanType.ENTERPRISE;

  // Upsert Subscription
  const subscription = await prisma.subscription.upsert({
    where: {
        teamId: teamId,
    },
    update: {
        status: SubscriptionStatus.ACTIVE,
        plan: planType,
        flutterwaveCustomerId: String(data.customer.id),
        amount: data.amount,
        currency: data.currency === 'NGN' ? Currency.NGN : Currency.USD,
        currentPeriodEnd: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // Approx 1 month
    },
    create: {
        teamId: teamId,
        status: SubscriptionStatus.ACTIVE,
        plan: planType,
        flutterwaveCustomerId: String(data.customer.id),
        amount: data.amount,
        currency: data.currency === 'NGN' ? Currency.NGN : Currency.USD,
        currentPeriodEnd: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
    }
  });

  // Create Invoice Record
  await prisma.invoice.create({
      data: {
          subscriptionId: subscription.id,
          amount: data.amount,
          currency: data.currency === 'NGN' ? Currency.NGN : Currency.USD,
          status: 'paid',
          flutterwaveRef: String(data.id), // Transaction ID
      }
  });
}

async function handleSubscriptionCancelled(data: any) {
    // Find subscription by customer email or ID
    // data might contain customer info
    const email = data.customer.email;
    
    // This is tricky if multiple teams have same email creator? 
    // Ideally store flutterwaveSubscriptionId
    
    // For now, assume we can match by email or we need to query user -> team -> sub
    // But better to use the subscription ID if we stored it.
    
    // Implementation of cancellation handling would go here.
    console.log('Subscription cancelled for:', email);
}
