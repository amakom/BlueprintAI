import { useState, useRef, useEffect } from 'react';
import {
  Download,
  FileText,
  Copy,
  Share2,
  Check,
  Printer,
  ChevronDown,
  Loader2,
  Globe,
  Bot
} from 'lucide-react';
import { useCanvas } from './CanvasContext';
import { useReactFlow } from '@xyflow/react';

interface ExportMenuProps {
  projectId: string;
}

export function ExportMenu({ projectId }: ExportMenuProps) {
  const [isOpen, setIsOpen] = useState(false);
  const [isShareModalOpen, setIsShareModalOpen] = useState(false);
  const [shareLink, setShareLink] = useState<string | null>(null);
  const [isLoadingShare, setIsLoadingShare] = useState(false);
  const [copied, setCopied] = useState(false);
  const [copiedAI, setCopiedAI] = useState(false);
  const [isLoadingAI, setIsLoadingAI] = useState(false);

  const menuRef = useRef<HTMLDivElement>(null);
  const { nodes, edges } = useCanvas();
  const { getNodes, getEdges } = useReactFlow();

  useEffect(() => {
    function handleClickOutside(event: MouseEvent) {
      if (menuRef.current && !menuRef.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    }
    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  const getPRDContent = () => {
    const currentNodes = nodes.length > 0 ? nodes : getNodes();
    const userStories = currentNodes.filter(n => n.type === 'userStory');
    
    // Sort by Y position to maintain some order
    userStories.sort((a, b) => a.position.y - b.position.y);

    let content = `# Project Requirements Document\n\n`;
    content += `Generated by BlueprintAI\n\n`;
    content += `## User Stories (${userStories.length})\n\n`;

    userStories.forEach(story => {
      content += `### ${story.data.label || 'Untitled Story'}\n`;
      content += `${story.data.description || 'No description provided.'}\n\n`;
      content += `---\n\n`;
    });

    return content;
  };

  const handleExportMarkdown = () => {
    const content = getPRDContent();
    const blob = new Blob([content], { type: 'text/markdown' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `prd-${projectId}.md`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    setIsOpen(false);
  };

  const handleCopyToClipboard = async () => {
    const content = getPRDContent();
    await navigator.clipboard.writeText(content);
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
    setIsOpen(false);
  };

  const buildFullAIPrompt = async (): Promise<string> => {
    // Fetch all project context from the API
    let context: any = null;
    try {
      const res = await fetch(`/api/projects/${projectId}/context`);
      if (res.ok) {
        context = await res.json();
      }
    } catch (err) {
      console.error('Failed to fetch project context', err);
    }

    // Get canvas data from React Flow (most up-to-date)
    const currentNodes = nodes.length > 0 ? nodes : getNodes();
    const currentEdges = edges.length > 0 ? edges : getEdges();
    const userStories = currentNodes.filter(n => n.type === 'userStory');
    const screens = currentNodes.filter(n => n.type === 'screen');

    userStories.sort((a, b) => a.position.y - b.position.y);
    screens.sort((a, b) => a.position.y - b.position.y);

    // Build node ID → label map for edge resolution
    const nodeMap: Record<string, string> = {};
    currentNodes.forEach(n => {
      const d = n.data as any;
      nodeMap[n.id] = d.label || n.type || 'Unknown';
    });

    let prompt = '';

    // === HEADER ===
    const projectName = context?.project?.name || 'Untitled Project';
    const projectDesc = context?.project?.description || '';
    prompt += `# Product Blueprint: ${projectName}\n`;
    prompt += `> Generated by BlueprintAI — use this as your complete development specification.\n\n`;

    if (projectDesc) {
      prompt += `## Project Description\n${projectDesc}\n\n`;
    }

    // === TARGET USERS / PERSONAS ===
    if (context?.personas && context.personas.length > 0) {
      prompt += `## Target Users (Personas)\n`;
      context.personas.forEach((p: any, i: number) => {
        prompt += `\n### ${i + 1}. ${p.name} — ${p.role}\n`;
        if (p.bio) prompt += `${p.bio}\n`;
        if (p.goals?.length > 0) {
          prompt += `**Goals:** ${p.goals.join(', ')}\n`;
        }
        if (p.frustrations?.length > 0) {
          prompt += `**Pain Points:** ${p.frustrations.join(', ')}\n`;
        }
      });
      prompt += `\n`;
    }

    // === OKRs ===
    if (context?.okrs && context.okrs.length > 0) {
      prompt += `## Objectives & Key Results (OKRs)\n`;
      context.okrs.forEach((okr: any, i: number) => {
        prompt += `\n### Objective ${i + 1}: ${okr.objective}\n`;
        if (okr.keyResults) {
          const krs = Array.isArray(okr.keyResults) ? okr.keyResults : [];
          krs.forEach((kr: any, j: number) => {
            const krText = typeof kr === 'string' ? kr : kr.title || kr.text || JSON.stringify(kr);
            prompt += `- KR${j + 1}: ${krText}\n`;
          });
        }
      });
      prompt += `\n`;
    }

    // === KPIs ===
    if (context?.kpis && context.kpis.length > 0) {
      prompt += `## Success Metrics (KPIs)\n`;
      context.kpis.forEach((kpi: any) => {
        prompt += `- **${kpi.name}**: Target ${kpi.target} (Status: ${kpi.status})\n`;
      });
      prompt += `\n`;
    }

    // === COMPETITORS ===
    if (context?.competitors && context.competitors.length > 0) {
      prompt += `## Competitive Landscape\n`;
      context.competitors.forEach((c: any) => {
        prompt += `\n### ${c.name}${c.website ? ` (${c.website})` : ''}\n`;
        if (c.strengths?.length > 0) {
          prompt += `**Strengths:** ${c.strengths.join(', ')}\n`;
        }
        if (c.weaknesses?.length > 0) {
          prompt += `**Weaknesses:** ${c.weaknesses.join(', ')}\n`;
        }
      });
      prompt += `\n`;
    }

    // === STRATEGY DOC ===
    if (context?.strategyDoc?.content) {
      prompt += `## Product Strategy\n`;
      const content = context.strategyDoc.content;
      if (typeof content === 'string') {
        prompt += `${content}\n\n`;
      } else if (content.markdown) {
        prompt += `${content.markdown}\n\n`;
      } else if (content.sections) {
        const sections = Array.isArray(content.sections) ? content.sections : [];
        sections.forEach((s: any) => {
          prompt += `### ${s.title || 'Section'}\n${s.content || s.body || ''}\n\n`;
        });
      } else {
        prompt += `${JSON.stringify(content, null, 2)}\n\n`;
      }
    }

    // === USER STORIES ===
    if (userStories.length > 0) {
      prompt += `## User Stories (${userStories.length})\n`;
      userStories.forEach((story, i) => {
        const d = story.data as any;
        prompt += `${i + 1}. **${d.label || 'Untitled'}**: ${d.description || 'No description.'}\n`;
      });
      prompt += `\n`;
    }

    // === SCREENS & PAGES ===
    if (screens.length > 0) {
      prompt += `## Screens & Pages (${screens.length})\n`;
      screens.forEach((screen, i) => {
        const d = screen.data as any;
        const route = String(d.label || 'screen').toLowerCase().replace(/\s+/g, '-');
        prompt += `${i + 1}. **${d.label || 'Untitled Screen'}** — Route: \`/${route}\`\n`;
        if (d.description) {
          prompt += `   ${d.description}\n`;
        }
      });
      prompt += `\n`;
    }

    // === USER FLOW (from edges) ===
    if (currentEdges.length > 0) {
      prompt += `## User Flow (Navigation Map)\n`;
      prompt += `These connections define how users move through the app:\n`;
      currentEdges.forEach((edge) => {
        const from = nodeMap[edge.source] || edge.source;
        const to = nodeMap[edge.target] || edge.target;
        prompt += `- ${from} → ${to}\n`;
      });
      prompt += `\n`;
    }

    // === ENGINEERING SPEC (if exists) ===
    if (context?.spec?.content) {
      prompt += `## Engineering Specification\n`;
      const spec = context.spec.content;
      if (typeof spec === 'string') {
        prompt += `${spec}\n\n`;
      } else if (spec.markdown) {
        prompt += `${spec.markdown}\n\n`;
      } else {
        prompt += `${JSON.stringify(spec, null, 2)}\n\n`;
      }
    }

    // === IMPLEMENTATION INSTRUCTIONS ===
    prompt += `## Implementation Instructions\n`;
    prompt += `Build this application following these guidelines:\n\n`;
    prompt += `1. **Database First** — Create the database schema based on the entities, user stories, and screens above\n`;
    prompt += `2. **API Layer** — Build RESTful API routes for each entity and user action\n`;
    prompt += `3. **Frontend Pages** — Build each screen listed above as a page/component\n`;
    prompt += `4. **User Flows** — Implement the navigation map exactly as specified\n`;
    prompt += `5. **Auth & Permissions** — Add authentication and role-based access for each persona type\n`;
    prompt += `6. **Validation** — Add proper form validation, error handling, and loading states\n`;
    prompt += `7. **Testing** — Test all user flows end-to-end\n\n`;
    prompt += `> This blueprint was generated by BlueprintAI. All sections above are interconnected — the personas define who uses each screen, the KPIs define what success looks like, and the user flow defines the navigation.\n`;

    return prompt;
  };

  const handleCopyForAI = async () => {
    setIsLoadingAI(true);
    setIsOpen(false);
    try {
      const prompt = await buildFullAIPrompt();
      await navigator.clipboard.writeText(prompt);
      setCopiedAI(true);
      setTimeout(() => setCopiedAI(false), 3000);
    } catch (err) {
      console.error('Failed to build AI prompt', err);
    } finally {
      setIsLoadingAI(false);
    }
  };

  const handlePrintPDF = () => {
    const content = getPRDContent();
    // Convert markdown-like text to simple HTML for printing
    const htmlContent = content
      .replace(/^# (.*$)/gim, '<h1>$1</h1>')
      .replace(/^## (.*$)/gim, '<h2>$1</h2>')
      .replace(/^### (.*$)/gim, '<h3>$1</h3>')
      .replace(/\n/gim, '<br>')
      .replace(/---/gim, '<hr>');

    const printWindow = window.open('', '_blank');
    if (printWindow) {
      printWindow.document.write(`
        <html>
          <head>
            <title>PRD Export</title>
            <style>
              body { font-family: system-ui, sans-serif; line-height: 1.5; max-width: 800px; margin: 0 auto; padding: 2rem; color: #0B1F33; }
              h1 { color: #0B1F33; border-bottom: 2px solid #2EE6D6; padding-bottom: 0.5rem; }
              h2 { color: #0B1F33; margin-top: 2rem; }
              h3 { color: #0B1F33; margin-top: 1.5rem; }
              hr { border: none; border-top: 1px solid #e2e8f0; margin: 2rem 0; }
              @media print {
                body { padding: 0; }
                button { display: none; }
              }
            </style>
          </head>
          <body>
            ${htmlContent}
            <script>
              window.onload = () => { window.print(); }
            </script>
          </body>
        </html>
      `);
      printWindow.document.close();
    }
    setIsOpen(false);
  };

  const handleShareClick = async () => {
    setIsShareModalOpen(true);
    setIsOpen(false);
    
    if (!shareLink) {
      setIsLoadingShare(true);
      try {
        // Fetch existing link
        const res = await fetch(`/api/projects/${projectId}/share`);
        if (res.ok) {
          const data = await res.json();
          if (data.token) {
            setShareLink(`${window.location.origin}/share/${data.token}`);
          }
        }
      } catch (err) {
        console.error('Failed to fetch share link', err);
      } finally {
        setIsLoadingShare(false);
      }
    }
  };

  const handleGenerateLink = async () => {
    setIsLoadingShare(true);
    try {
      const res = await fetch(`/api/projects/${projectId}/share`, { method: 'POST' });
      if (res.ok) {
        const data = await res.json();
        setShareLink(`${window.location.origin}/share/${data.token}`);
      }
    } catch (err) {
      console.error('Failed to generate share link', err);
    } finally {
      setIsLoadingShare(false);
    }
  };

  const handleCopyLink = () => {
    if (shareLink) {
      navigator.clipboard.writeText(shareLink);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    }
  };

  return (
    <div className="relative" ref={menuRef}>
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="flex items-center gap-2 bg-white border border-border px-3 py-2 rounded-md shadow-sm hover:bg-gray-50 text-navy transition-colors text-sm font-medium"
      >
        <Share2 className="w-4 h-4" />
        Export & Share
        <ChevronDown className={`w-3 h-3 transition-transform ${isOpen ? 'rotate-180' : ''}`} />
      </button>

      {isOpen && (
        <div className="absolute top-full right-0 mt-2 w-56 bg-white border border-border rounded-md shadow-lg z-50 overflow-hidden animate-in fade-in zoom-in-95 duration-100">
          <div className="p-1">
            <button onClick={handleExportMarkdown} className="w-full flex items-center gap-2 px-3 py-2 text-sm text-navy hover:bg-cloud rounded-md text-left">
              <Download className="w-4 h-4 text-gray-500" />
              Export Markdown
            </button>
            <button onClick={handlePrintPDF} className="w-full flex items-center gap-2 px-3 py-2 text-sm text-navy hover:bg-cloud rounded-md text-left">
              <Printer className="w-4 h-4 text-gray-500" />
              Print / Save as PDF
            </button>
            <button onClick={handleCopyToClipboard} className="w-full flex items-center gap-2 px-3 py-2 text-sm text-navy hover:bg-cloud rounded-md text-left">
              {copied ? <Check className="w-4 h-4 text-green-500" /> : <Copy className="w-4 h-4 text-gray-500" />}
              Copy PRD to Clipboard
            </button>
            <button onClick={handleCopyForAI} disabled={isLoadingAI} className="w-full flex items-center gap-2 px-3 py-2 text-sm text-navy hover:bg-purple-50 rounded-md text-left font-medium disabled:opacity-50">
              {isLoadingAI ? <Loader2 className="w-4 h-4 text-purple-600 animate-spin" /> : copiedAI ? <Check className="w-4 h-4 text-green-500" /> : <Bot className="w-4 h-4 text-purple-600" />}
              {isLoadingAI ? 'Building Context...' : copiedAI ? 'Copied!' : 'Copy for AI Agent'}
            </button>
            <div className="h-px bg-border my-1" />
            <button onClick={handleShareClick} className="w-full flex items-center gap-2 px-3 py-2 text-sm text-navy hover:bg-cloud rounded-md text-left">
              <Globe className="w-4 h-4 text-cyan" />
              Share Public Link
            </button>
          </div>
        </div>
      )}

      {/* Share Modal */}
      {isShareModalOpen && (
        <div className="fixed inset-0 z-[100] flex items-center justify-center bg-black/50 backdrop-blur-sm">
          <div className="bg-white rounded-md shadow-2xl w-full max-w-md p-6 m-4 animate-in fade-in zoom-in-95">
            <div className="flex justify-between items-center mb-4">
              <h3 className="text-lg font-bold text-navy flex items-center gap-2">
                <Globe className="w-5 h-5 text-cyan" />
                Share Project
              </h3>
              <button onClick={() => setIsShareModalOpen(false)} className="text-gray-400 hover:text-navy">
                <span className="sr-only">Close</span>
                <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" /></svg>
              </button>
            </div>
            
            <p className="text-sm text-gray-600 mb-4">
              Anyone with this link can view the project canvas in read-only mode.
            </p>

            {isLoadingShare ? (
              <div className="flex justify-center py-4">
                <Loader2 className="w-6 h-6 animate-spin text-cyan" />
              </div>
            ) : shareLink ? (
              <div className="space-y-3">
                <div className="flex gap-2">
                  <input 
                    readOnly 
                    value={shareLink} 
                    className="flex-1 text-sm border border-border rounded-md px-3 py-2 bg-gray-50 text-gray-600 outline-none focus:ring-2 focus:ring-cyan/20"
                  />
                  <button 
                    onClick={handleCopyLink}
                    className="bg-navy text-white px-3 py-2 rounded-md hover:bg-navy/90 transition-colors flex items-center gap-2"
                  >
                    {copied ? <Check className="w-4 h-4" /> : <Copy className="w-4 h-4" />}
                  </button>
                </div>
                <div className="flex justify-between items-center text-xs text-gray-500">
                  <span>Link is active</span>
                  <button 
                    onClick={handleGenerateLink}
                    className="text-cyan hover:underline"
                  >
                    Regenerate Link
                  </button>
                </div>
              </div>
            ) : (
              <div className="text-center py-2">
                <button 
                  onClick={handleGenerateLink}
                  className="bg-cyan text-navy font-bold px-4 py-2 rounded-md hover:bg-cyan/90 transition-colors w-full"
                >
                  Generate Public Link
                </button>
              </div>
            )}
          </div>
        </div>
      )}
    </div>
  );
}
